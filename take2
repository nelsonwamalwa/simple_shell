#include "shell.h"


void displayPrompt(void)
{
	if (isatty(STDIN_FILENO))
	{
		printf("Shelly> ");
		fflush(stdout);
	}
}

int isComment(const char *token) {
    return (token[0] == '#');
}

ssize_t getCommand(char **command, size_t *commandSize)
{
	return (getline(command, commandSize, stdin));
}

void executeCommand(char **args)
{
	execvp(args[0], args);
	perror("Command execution error");
	exit(EXIT_FAILURE);
}
void waitForChildProcess(pid_t childPid)
{
	int childStatus;

	waitpid(childPid, &childStatus, 0);
	if (WIFEXITED(childStatus))
	{
		(void)WEXITSTATUS(childStatus);
	}
}

int parseInput(char *line, char *args[]) {
    int argc = 0;
    char *token = strtok(line, " ");

    while (token != NULL && argc < MAX_ARGS - 1) {
        if (!isComment(token)) {
            args[argc++] = token;
        }
        token = strtok(NULL, " ");
    }
    args[argc] = NULL;

    return argc;
}

int main(void)
{
	char *command = NULL;
	size_t commandSize = 0;

	while (1)
	{
		ssize_t bytesRead;
		pid_t childPid;
		char *args[MAX_ARGS];

		int argCount = 0;
		char *token;

		displayPrompt();
		bytesRead = getCommand(&command, &commandSize);
		if (bytesRead == -1)
		{
			if (feof(stdin))
				break;
			perror("Input error");
			clearerr(stdin);
			continue;
		}
		if (command[bytesRead - 1] == '\n')
		{
			command[bytesRead - 1] = '\0';
		}
		token = strtok(command, " ");
		while (token != NULL && argCount < MAX_ARGS - 1)
		{
			if (!isComment(token))
			{
				args[argCount++] = token;
			}
		token = strtok(NULL, " ");
		}
		args[argCount] = NULL;
		childPid = fork();
		if (childPid < 0)
		{
			perror("Fork error");
		}
		else if (childPid == 0)
		{
			executeCommand(args);
		}
		else
		{
			waitForChildProcess(childPid);
		}
	}
	free(command);

	return (0);
}
